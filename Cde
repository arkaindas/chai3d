export class SpinWheel {
  constructor(canvasId, options = {}) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext("2d");

    this.segments = options.segments || ["A", "B", "C", "D", "E"];
    this.colors = options.colors || ["#18c37a", "#ffffff"];
    this.onResult = options.onResult || (() => {});

    this.rotation = 0;
    this.isSpinning = false;
    this.highlightIndex = null; // winner highlight index

    this.resizeCanvas();
    window.addEventListener("resize", () => this.resizeCanvas());
    this.draw();
  }

  resizeCanvas() {
    const size = Math.min(this.canvas.parentElement.offsetWidth, 400);
    this.canvas.width = size;
    this.canvas.height = size;
    this.size = size / 2;
    this.draw();
  }

  draw() {
    const { ctx, size, segments, colors } = this;
    ctx.clearRect(0, 0, size * 2, size * 2);
    const anglePerSeg = (2 * Math.PI) / segments.length;

    segments.forEach((label, i) => {
      const start = i * anglePerSeg;
      const end = start + anglePerSeg;

      // Highlight winner segment
      if (this.highlightIndex === i) {
        ctx.shadowBlur = 25;
        ctx.shadowColor = "rgba(255, 223, 0, 0.8)";
      } else {
        ctx.shadowBlur = 0;
      }

      // Draw slice
      ctx.beginPath();
      ctx.moveTo(size, size);
      ctx.arc(size, size, size, start, end);
      ctx.fillStyle = colors[i % colors.length];
      ctx.fill();

      // Draw text
      ctx.save();
      ctx.translate(size, size);
      ctx.rotate(start + anglePerSeg / 2);
      ctx.textAlign = "right";
      ctx.fillStyle = "#000";
      ctx.font = `${Math.max(size / 14, 10)}px Poppins`;
      ctx.fillText(label, size - 10, 5);
      ctx.restore();
    });
    ctx.shadowBlur = 0; // reset
  }

  spin() {
    if (this.isSpinning) return;
    this.isSpinning = true;
    this.highlightIndex = null;

    const duration = 4000;
    const spins = Math.random() * 5 + 5;
    const finalAngle = spins * 360 + Math.random() * 360;
    const start = performance.now();

    const animate = (now) => {
      const elapsed = now - start;
      const progress = Math.min(elapsed / duration, 1);
      const easeOut = 1 - Math.pow(1 - progress, 3);
      const angle = finalAngle * easeOut;

      this.rotation = angle * (Math.PI / 180);
      this.drawRotated();

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        this.isSpinning = false;
        this.triggerResult();
      }
    };

    requestAnimationFrame(animate);
  }

  drawRotated() {
    const { ctx, canvas, size } = this;
    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.translate(size, size);
    ctx.rotate(this.rotation);
    ctx.translate(-size, -size);
    this.draw();
    ctx.restore();
  }

  triggerResult() {
    const segmentAngle = (2 * Math.PI) / this.segments.length;
    let currentAngle = this.rotation % (2 * Math.PI);
    let topAngle = (Math.PI / 2 - currentAngle + 2 * Math.PI) % (2 * Math.PI);
    const index = Math.floor(topAngle / segmentAngle) % this.segments.length;
    const value = this.segments[index];

    this.highlightIndex = index;
    this.drawRotated();

    // ðŸ”† Animate glow for 1.5s
    let glowStart = performance.now();
    const glow = (now) => {
      const t = (now - glowStart) / 1500;
      if (t < 1) {
        this.drawRotated();
        requestAnimationFrame(glow);
      } else {
        this.highlightIndex = null;
        this.drawRotated();
        this.onResult(value);
      }
    };
    requestAnimationFrame(glow);
  }
}
